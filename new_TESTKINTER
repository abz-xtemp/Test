from tkinter import *
from tkinter import filedialog
from tkinter.scrolledtext import ScrolledText
import datetime
import openpyxl
from tktimepicker import SpinTimePickerModern, constants
from tkcalendar import DateEntry
import os
import xlwings
import time
import traceback
import subprocess
import pandas as pd
from threading import Thread

# Define a modern and aesthetic color scheme
COLOR_SCHEME = {
    "background": "#F5F5F5",  # Light gray background
    "primary": "#4CAF50",  # Green for primary elements
    "secondary": "#2196F3",  # Blue for secondary elements
    "accent": "#FFC107",  # Amber for accents
    "error": "#F44336",  # Red for errors
    "success": "#4CAF50",  # Green for success
    "text": "#212121",  # Dark gray for text
    "button_bg": "#E0E0E0",  # Light gray for buttons
    "button_fg": "#000000",  # Black for button text
    "button_hover": "#BDBDBD",  # Darker gray for button hover
    "frame_bg": "#FFFFFF",  # White for frames
    "highlight": "#FF5722",  # Orange for highlights
}

class WelcomeScreen:
    def __init__(self):
        self.Window = Tk()
        self.Window_Config()
        self.Title_Bar()
        self.Buttons()
        self.Window.mainloop()

    def Window_Config(self):
        self.Window.wm_title('Auto Automation')
        width = 500
        height = 300
        screen_width = self.Window.winfo_screenwidth()
        screen_height = self.Window.winfo_screenheight()
        x = (screen_width / 2) - (width / 2)
        y = (screen_height / 2) - (height / 2)
        self.Window.geometry('%dx%d+%d+%d' % (width, height, x, y))
        self.Window.configure(bg=COLOR_SCHEME["background"])
        self.Window.resizable(False, False)

    def Title_Bar(self):
        self.Title = Label(self.Window, text='Welcome to Auto Automation', width=45, padx=0, pady=0, 
                           font=('Arial', 16, 'bold'), fg='white', bg=COLOR_SCHEME["primary"])
        self.Title.grid(row=0, column=0, padx=5, pady=20, columnspan=10, sticky='e')

    def Buttons(self):
        self.Excel_Button = Button(self.Window, text='Run/Schedule via Excel', command=self.Open_Excel_GUI, width=20, 
                                   font=('Arial', 12, 'bold'), fg=COLOR_SCHEME["button_fg"], bg=COLOR_SCHEME["button_bg"], 
                                   relief='flat', activebackground=COLOR_SCHEME["button_hover"])
        self.Excel_Button.grid(row=1, column=0, padx=5, pady=10)

        self.RunOnce_Button = Button(self.Window, text='Run Once', command=self.Open_RunOnce_GUI, width=20, 
                                     font=('Arial', 12, 'bold'), fg=COLOR_SCHEME["button_fg"], bg=COLOR_SCHEME["button_bg"], 
                                     relief='flat', activebackground=COLOR_SCHEME["button_hover"])
        self.RunOnce_Button.grid(row=2, column=0, padx=5, pady=10)

    def Open_Excel_GUI(self):
        self.Window.destroy()
        Instance = AutoAuto()
        Instance.Start_Window()

    def Open_RunOnce_GUI(self):
        self.Window.destroy()
        Instance = RunOnce()
        Instance.Start_Window()


class RunOnce:
    def __init__(self):
        self.Window = Tk()
        self.Window_Config()
        self.Title_Bar()
        self.File_Selection()
        self.Console_Frame()
        self.Window.mainloop()

    def Window_Config(self):
        self.Window.wm_title('Run Once')
        width = 600
        height = 400
        screen_width = self.Window.winfo_screenwidth()
        screen_height = self.Window.winfo_screenheight()
        x = (screen_width / 2) - (width / 2)
        y = (screen_height / 2) - (height / 2)
        self.Window.geometry('%dx%d+%d+%d' % (width, height, x, y))
        self.Window.configure(bg=COLOR_SCHEME["background"])
        self.Window.resizable(False, False)

    def Title_Bar(self):
        self.Title = Label(self.Window, text='Run Once: Drag & Drop or Browse Files', width=45, padx=0, pady=0, 
                           font=('Arial', 16, 'bold'), fg='white', bg=COLOR_SCHEME["primary"])
        self.Title.grid(row=0, column=0, padx=5, pady=20, columnspan=10, sticky='e')

    def File_Selection(self):
        self.File_Frame = Frame(self.Window, width=550, height=150, bg=COLOR_SCHEME["frame_bg"], highlightbackground="black", highlightthickness=1)
        self.File_Frame.grid(row=1, column=0, padx=5, pady=10)

        self.Browse_Button = Button(self.File_Frame, text='Browse Files', command=self.Browse_Files, width=20, 
                                    font=('Arial', 12, 'bold'), fg=COLOR_SCHEME["button_fg"], bg=COLOR_SCHEME["button_bg"], 
                                    relief='flat', activebackground=COLOR_SCHEME["button_hover"])
        self.Browse_Button.grid(row=0, column=0, padx=5, pady=10)

        self.Run_Button = Button(self.File_Frame, text='Run', command=self.Run_Files, width=20, 
                                 font=('Arial', 12, 'bold'), fg='white', bg=COLOR_SCHEME["success"], 
                                 relief='flat', activebackground=COLOR_SCHEME["button_hover"])
        self.Run_Button.grid(row=0, column=1, padx=5, pady=10)

    def Browse_Files(self):
        files = filedialog.askopenfilenames(title="Select Files", filetypes=(("Python Files", "*.py"), ("All Files", "*.*")))
        if files:
            self.Selected_Files = files
            self.Update_Console(f"Selected Files: {', '.join(files)}")

    def Run_Files(self):
        if not hasattr(self, 'Selected_Files'):
            self.Update_Console("No files selected. Please browse and select files.")
            return

        for file in self.Selected_Files:
            self.Update_Console(f"Executing: {file}")
            try:
                subprocess.run(['python', file], check=True)
                self.Update_Console(f"Finished: {file}")
            except Exception as e:
                self.Update_Console(f"Error executing {file}: {str(e)}")

    def Console_Frame(self):
        self.Console_Frame = Frame(self.Window, width=550, height=200, bg=COLOR_SCHEME["frame_bg"], highlightbackground="black", highlightthickness=1)
        self.Console_Frame.grid(row=2, column=0, padx=5, pady=10)

        self.Console_Out = ScrolledText(self.Console_Frame, width=65, height=10, bg=COLOR_SCHEME["frame_bg"], fg=COLOR_SCHEME["text"])
        self.Console_Out.pack(fill=BOTH, side=LEFT, expand=True)

        self.Curr_Data = "Console Output:\n"
        self.Console_Out.bind('<Control-v>', lambda _: 'break')
        self.Console_Out.bind('<BackSpace>', lambda _: 'break')
        self.Update_Console(self.Curr_Data)

    def Update_Console(self, WData):
        self.Curr_Data += WData + '\n'
        self.Console_Out.insert('end', WData + '\n')
        self.Console_Out.see('end')


# Your original AutoAuto class
class AutoAuto:
    def __init__(self):
        self.Data_Structures()
        self.Read_Automations()
        self.Window = Tk()
        self.Window_Config()
        self.Title_Bar()
        self.Section_Bar()
        self.Function_Frame()
        self.Config_Frame()
        self.Timer_Frame()
        self.Console_Frame()

    def Read_Automations(self):
        if self.C_Exists:
            try:
                Auto_DF = pd.read_excel(self.CTarget, sheet_name='Configuration')
                
                # Check if required columns exist
                required_columns = ['Automation Name', 'Main Script(s)', 'Template (If any)', 'Interpreter']
                if not all(column in Auto_DF.columns for column in required_columns):
                    self.Update_Console("Error: Required columns are missing in the Excel file.")
                    return
                
                # Check if there is at least one row of data
                if Auto_DF.empty:
                    self.Update_Console("Error: No data found in the Excel file.")
                    return
                
                # Read data
                Automations = Auto_DF['Automation Name']
                Main_Script = Auto_DF['Main Script(s)']
                Template = Auto_DF['Template (If any)']
                self.Py_Interpreter = str(Auto_DF['Interpreter'].iloc[0])  # Get the first interpreter
                
                # Populate Function_Invoke dictionary
                self.Function_Invoke = {}
                for A, M, T in zip(Automations, Main_Script, Template):
                    self.Function_Invoke[A] = [M, False, T]
            
            except Exception as e:
                self.Update_Console(f"Error reading Excel file: {str(e)}")
        else:
            self.Update_Console("Configuration file not found. Please create one.")

    def C_Driver(self):
        if self.C_Exists:
            try:
                ConfigBook = xlwings.Book(self.CTarget)
            except Exception as e:
                self.Update_Console(f"Error opening Excel file: {str(e)}")
        else:
            self.Config_MAKE()
            self.Config_Frame()

    def Data_Structures(self):
        self.Py_Interpreter = 'python'  # Default interpreter
        self.OutBound = [100000, 100000]
        self.Button_Names = ['NW', 'NE', 'W', 'E', 'SW', 'SE']
        self.Default_AutoFrame = 1
        self.Max_AutoFrame = 1
        self.FrameWise_Automation = {}
        self.Trigger_Cancel = False
        self.Function_Invoke = {}
        self.Config_Avail = False
        self.Current_Time = datetime.datetime.now().strftime('%H:%M').split(':')
        self.CTarget = os.getcwd() + '\\Config.xlsx'
        self.C_Exists = os.path.exists(self.CTarget)
        self.Wait_Period = 0
        self.Busy = False

    # ... (rest of your AutoAuto class code)

    def Start_Window(self):
        self.Window.mainloop()


if __name__ == "__main__":
    WelcomeScreen()
